# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#'
#' @title Derive the B-spline basis function value at a value x
#' @name bspline_basis
#'
#' @param j A \code{integer} referring to the knot interval where \code{x} is to be evaluated.
#' @param m A \code{integer} signifying the degree of the B-spline basis.
#' @param knots A \code{numeric} vector containing the knots for the B-spline basis.
#' @param x A \code{double} corresponding to the value which we seek the B-spline function value.
#'
#' @description Computes the B-spline function value evaluated at \code{x} for the \code{j}-th knot, when the degree of the B-spline basis is \code{m}.
#'
#' @details Used to recursively build the B-spline basis matrix B.
#'
#' @return A \code{double} that is the function value of the B-spline function evaluated at \code{x} for the \code{j}-th knot given the B-spline basis degree \code{m}.
#'
#' @examples \dontrun{
#'   print(1)
#' }
NULL

#'
#' @title Derive the B-spline basis matrix given values of x and the degree m
#' @name bspline_basis_matrix
#'
#' @param x A \code{numeric} vector containing the predictior values.
#' @param knots A \code{numeric} vector containing the knots for the B-spline basis.
#' @param m An \code{integer} that signify the desired degree of the B-spline basis. Default is 3 (cubic).
#'
#' @description Computes the B-spline basis matrix given the \code{knots} and the desired degree, \code{m}.
#'
#' @details Recursively build the B-spline basis matrix B. The construction of B uses the Cox-de Boor recursion formula.
#'
#' @return The constructed B-spline basis \code{matrix}.
#'
#' @examples \dontrun{
#'   print(1)
#' }
NULL

bspline_basis <- function(j, m, knots, x) {
    .Call(`_smooth_commutability_bspline_basis`, j, m, knots, x)
}

bspline_basis_matrix <- function(x, knots, m = 3L) {
    .Call(`_smooth_commutability_bspline_basis_matrix`, x, knots, m)
}

#' Estimate \eqn{\mathrm{df}^2(c)}
#'
#' @title Estimate \eqn{\mathrm{df}^2(c)}
#' @name df_2
#'
#' @param df_grid A \code{numeric} vector containing the candidate degrees of freedom for smoothing splines. Missing values are allowed.
#' @param cv A \code{numeric} vector contaning cross-validation values for various smoothing splines fit associated with the degrees of freedom found in \code{df_grid}. Missing values are allowed.
#' @param df_0 A \code{double} between 2 and the maximum value of \code{df_grid} representing the traditional optimal degrees of freedom. This is typically the minimized of the cross-validation curve.
#' @param D A positive \code{double} representing the largest allowable angle of the slopes of the cross-validation curve.
#' @param tol A non-negative \code{double} representing the maximum allowable difference between the angle of each slope of the cross-validation curve and \code{D}.
#' @param silence A \code{logical} value. If set to \code{TRUE}, informative messages are printed to the console regarding the iterative process of choosing \eqn{\mathrm{df}^2(c)}.
#'
#' @description Estimate a more conservative degrees of freedom, \eqn{\mathrm{df}^2(c)}, through an iterative process: starting from the degress of freedom immediately to the left of \eqn{\mathrm{df}^0(c)} on the degrees of freedom grid, \code{df_grid}, we examine its associated angle. If this angle does not exceed the threshold, \code{D}, we proceed to the next closest degrees of freedom and evaluate its angle. This process is repeated, moving leftward along the grid, until we identify the first angle that surpasses the threshold. The value of \eqn{\mathrm{df}^2(c)} is then assigned as the degrees of freedom corresponding to the position immediately preceding the one where the angle first exceeded \code{D}.
#'
#' @details Caution is required. With a limited length of \code{df_grid}, it is possible that no angle fall below \code{D}. Even if the length of \code{df_grid}, it is not assured that there exists a cross-validation curve slope smaller than \code{D}. Therefore, ensuring that that \code{D} is not set too low, will increase the likelihood of obtaining a meaningful value of \eqn{\mathrm{df}^2(c)}. If the iterative process fail to find a suitable value of \eqn{\mathrm{df}^2(c)}, the input value of \code{df_0} will be returned.
#'
#' @return A \code{double} representing the resulting value of \eqn{\mathrm{df}^2(c)}.
#'
#' @examples \dontrun{
#'
#'   # Generate some fictional data
#'   test_df_grid <- seq(from = 2, to = 12, length.out = 100)
#'   test_cv <- 0.5 + 0.2 * (df_grid - 5)**2
#'   test_df_0 <- 5
#'
#'   # Using D = 2.5
#'   df_2(test_df_grid, test_cv, test_df_0, D = 2.5, tol = 0)
#'   df_2(test_df_grid, test_cv, test_df_0, D = 2.5, tol = 1/4)
#'
#'   # Using D = 5.0
#'   df_2(test_df_grid, test_cv, test_df_0, D = 5, tol = 0)
#'   df_2(test_df_grid, test_cv, test_df_0, D = 5, tol = 1/2)
#'
#' }
NULL

df_2 <- function(df_grid, cv, df_0, D, tol = 0, silence = TRUE) {
    .Call(`_smooth_commutability_df_2`, df_grid, cv, df_0, D, tol, silence)
}

rcpp_hello_world <- function() {
    .Call(`_smooth_commutability_rcpp_hello_world`)
}

