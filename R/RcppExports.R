# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Computes trace ratio between BTB and Omega
#'
#' @title Computes trace ratio between BTB and Omega
#' @name calculate_r
#'
#' @param BTB A \code{matrix}. Must have dimensions \eqn{(n+4) \times (n+4)}, where
#'        \eqn{n} is the total number of unique observations.
#' @param Omega A \code{matrix}. Must have dimensions \eqn{(n+4) \times (n+4)}.
#'
#' @details
#' The trace ratio between BTB and Omega, \eqn{r}, is calculated in the following manner:
#' \enumerate{
#'   \item Calculates the trace of \code{BTB} excluding the first \eqn{2} and last \eqn{3} elements. We call this \eqn{T_1}.
#'   \item Calculates the trace of \code{Omega} excluding the first \eqn{2} and last \eqn{3} elements. We call this \eqn{T_2}.
#'   \item Calculate and return \eqn{r = T_1 / T_2}
#' }
#' \eqn{r} is used in the conversion between \code{sp} and \code{lambda}.
#'
#' @return A \code{double}. The trace ratio between BTB and Omega.
#' @export
#'
#' @examples print(1)
NULL

#' Computes the inverse matrix of \eqn{B^{T}WB + \lambda \Omega}
#'
#' @title Computes the inverse matrix of \eqn{B^{T}WB + \lambda \Omega}
#' @name calculate_Q
#'
#' @param lambda A \code{double}. The computitional smoothing parameter.
#' @param BTB A \code{matrix}. The inner matrix product \eqn{B^{T}WB}.
#'        Must have dimensions \eqn{(n+4) \times (n+4)}.
#' @param Omega A \code{matrix}. The penalty matrix.
#'        Must have dimensions \eqn{(n+4) \times (n+4)}.
#'
#' @details
#' Calculates \eqn{Q = (B^{T}WB + \lambda \Omega)^{-1}}.
#'
#' @return A \eqn{(n+4) \times (n+4)} \code{matrix}, which we denote \eqn{Q}.
#' @export
#'
#' @examples print(1)
NULL

#' Calculates the Smoother Matrix \eqn{S}
#'
#' @title Calculates the Smoother Matrix \eqn{S}
#' @name calculate_S
#'
#' @param lambda A \code{double}. The computitional smoothing parameter.
#' @param weights A \code{numeric} vector of weights. Must be of length \eqn{n}.
#' @param B A \code{matrix}. The B-spline basis matrix.
#'        Must have dimensions \eqn{(n) \times (n+4)}.
#' @param BTB A \code{matrix}. The inner matrix product \eqn{B^{T}WB}.
#'        Must have dimensions \eqn{(n+4) \times (n+4)}.
#' @param Omega A \code{matrix}. The penalty matrix.
#'        Must have dimensions \eqn{(n+4) \times (n+4)}.
#'
#' @details
#' Calculates the smoother matrix by \eqn{S = B(B^{T}WB + \lambda \Omega)^{-1}B^{T}}.
#'
#' @return A \eqn{(n) \times (n)} \code{matrix}, which we denote \eqn{S}.
#' @export
#'
#' @examples print(1)
NULL

#' Calculates the Smoother Matrix \eqn{S}
#'
#' @title Calculates the Smoother Matrix \eqn{S}
#' @name calculate_S2
#'
#' @param weights A \code{numeric} vector of weights. Must be of length \eqn{n}.
#' @param B A \code{matrix}. The B-spline basis matrix.
#'        Must have dimensions \eqn{(n) \times (n+4)}.
#' @param Q A \code{matrix}. The matrix \eqn{Q = (B^{T}WB + \lambda \Omega)^{-1}}.
#'        Must have dimensions \eqn{(n+4) \times (n+4)}.
#'
#' @details
#' Calculates the smoother matrix by \eqn{S = BQB^{T}}.
#'
#' @return A \eqn{(n) \times (n)} \code{matrix}, which we denote \eqn{S}.
#' @export
#'
#' @examples print(1)
NULL

#' Calculates the matrix part, \eqn{L}, of the covariance matrix \eqn{\hat{\sigma}^2 \cdot L}
#'
#' @title Calculates the matrix part, \eqn{L} of the covariance matrix \eqn{\hat{\sigma}^2 \cdot L}
#' @name calculate_cov_beta
#'
#' @param BTB A \code{matrix}. The inner matrix product \eqn{B^{T}WB}.
#'        Alternatively, The inner matrix product \eqn{B^{T}WWB}.
#'        Must have dimensions \eqn{(n+4) \times (n+4)}.
#'
#' @param Q A \code{matrix}. The matrix \eqn{Q = (B^{T}WB + \lambda \Omega)^{-1}}.
#'        Must have dimensions \eqn{(n+4) \times (n+4)}.
#'
#' @details
#' Calculates \eqn{L} in the covariance matrix of the smoothing spline coefficients
#'
#' \eqn{\mathrm{Cov}[\hat{\beta}] = \hat{\sigma}^2 \cdot L}
#'
#' Where \eqn{L = QB^{T}WBQ}.
#'
#' @return A \eqn{(n+4) \times (n+4)} \code{matrix}, which we denote \eqn{L}.
#' @export
#'
#' @examples print(1)
NULL

#' Calculates the variance of predicted values
#'
#' @title Calculates the variance of predicted values
#' @name calculate_pred_var
#'
#' @param B_new A \code{matrix}. The possibly new B-spline basis matrix or its derivative.
#'        Must have dimensions \eqn{(m) \times (n+4)}.
#' @param cov_beta A \code{matrix}. The matrix \eqn{\hat{\sigma}^2 \cdot L}.
#'        Must have dimensions \eqn{(n+4) \times (n+4)}. See details
#'
#' @details
#' Calculates estimated variances of smoothing spline predicted values.
#' In fact we calculate the diagonal elements of
#'
#' \eqn{\mathrm{Cov}[\hat{\beta}] = \hat{\sigma}^2 \cdot L}
#'
#' Where \eqn{L = QB^{T}W_{a}BQ}, where
#' \itemize{
#'   \item \eqn{Q = (B^{T}WB + \lambda \Omega)^{-1}}
#'   \item \eqn{W_{a}} is either \eqn{W} or \eqn{WW^{T}}
#'   \item \eqn{B} is the original \eqn{n \times (n+4)} B-spline matrix.
#'   \item \eqn{\hat{\sigma}^2 = \mathrm{WRSS} / (n - \mathrm{df})}
#' }
#'
#' @return A \code{numeric} vector of length \eqn{m}. The estimated variances of
#'         the predicted values based on new observations.
#' @export
#'
#' @examples print(1)
NULL

#' Calculates the effective degrees of freedom \eqn{\mathrm{df}}
#'
#' @title Calculates the effective degrees of freedom \eqn{\mathrm{df}}
#' @name calculate_df
#'
#' @param lambda A \code{double}. The computitional smoothing parameter.
#' @param weights A \code{numeric} vector of weights. Must be of length \eqn{n}.
#' @param B A \code{matrix}. The B-spline basis matrix.
#'        Must have dimensions \eqn{(n) \times (n+4)}.
#' @param BTB A \code{matrix}. The inner matrix product \eqn{B^{T}WB}.
#'        Must have dimensions \eqn{(n+4) \times (n+4)}.
#' @param Omega A \code{matrix}. The penalty matrix.
#'        Must have dimensions \eqn{(n+4) \times (n+4)}.
#'
#' @details
#' Calculates the effective degrees of freedom \eqn{\mathrm{df}} by \eqn{\mathrm{tr}[B(B^{T}WB + \lambda \Omega)^{-1}B^{T}]}.
#' In other words, \eqn{\mathrm{df}} is just the trace of the smoother matrix \eqn{S}.
#'
#' @return A \code{double}. The effective degrees of freedom for the smoothing spline.
#' @export
#'
#' @examples print(1)
NULL

calculate_r <- function(BTB, Omega) {
    .Call(`_smooth_commutability_calculate_r`, BTB, Omega)
}

calculate_Q <- function(lambda, BTB, Omega) {
    .Call(`_smooth_commutability_calculate_Q`, lambda, BTB, Omega)
}

calculate_S <- function(lambda, weights, B, BTB, Omega) {
    .Call(`_smooth_commutability_calculate_S`, lambda, weights, B, BTB, Omega)
}

calculate_S2 <- function(weights, B, Q) {
    .Call(`_smooth_commutability_calculate_S2`, weights, B, Q)
}

calculate_cov_beta <- function(BTB, Q) {
    .Call(`_smooth_commutability_calculate_cov_beta`, BTB, Q)
}

calculate_pred_var <- function(B_new, cov_beta) {
    .Call(`_smooth_commutability_calculate_pred_var`, B_new, cov_beta)
}

calculate_df <- function(lambda, weights, B, BTB, Omega) {
    .Call(`_smooth_commutability_calculate_df`, lambda, weights, B, BTB, Omega)
}

#' Numerical Gradient Approximation Using Richardson Extrapolation
#'
#' @title Approximate Numerical Gradient for a Function \code{f}
#' @name numerical_gradient
#'
#' @param x A \code{double}. The point where \code{f} is to be evaluated.
#' @param f A \code{function}. If the function have more than 1 argument, ensure that these are fixed.
#' @param eps A \code{double}. The delta value in which the gradient are approximated.
#' @param r An \code{integer}. The number of Iterations utilized for the Richardson extrapolation algorithm.
#'
#' @details
#' Given a particular vale of \code{x}, approximates the gradient of \code{f(x)} at this point.
#'
#' @return A \code{double} that signify the approximated gradient of \code{f} evaluated at \code{x}.
#' @export
#'
#' @examples
#' example_fun <- function(x, a = 3){return((x - a)^2)}
#' gradient_at_minimum <- numerical_gradient(3, function(x) example_fun(3, 3))
#'
#' # Expected to be approximately '0'
#' print(gradient_at_minimum)
NULL

#' Numerical Minimization Using Brent's Algorithm
#'
#' @title Obtain the value of \code{x} so that \code{f(x)} is a local minimum
#' @name brent_min
#'
#' @param f A \code{function}. Must be defined and continuous in the domain \code{[a, b]}. If the function have more than 1 argument, ensure that these are fixed.
#' @param a A \code{double}. The lower bound for the search interval.
#' @param b A \code{double}. The upper bound for the search interval.
#' @param tol A \code{double}. The desired accuracy.
#' @param max_iter An \code{integer}. The maximum number of iteration that should be performed before the algorithm forces to quit.
#'
#' @details
#' Given a particular function \code{f}, obtains a local minimum of \code{f} in the domain \code{[a, b]}. Brent's algorithm uses a combination of golden section search and quadratic interpolation to obtain the minimum.
#'
#' @return A \code{double} that signify the value of \code{x} that results in local minimum of \code{f}.
#' @export
#'
#' @examples
#' example_fun <- function(x, a = 3){return((x - a)^2)}
#' the_minimum <- brent_min(f = function(x) example_fun(x, 3), a = -3, b = 6)
#'
#' # Expected to be approximately '3'
#' print(the_minimum)
#'
#' # The value of f at the minimum
#' print(example_fun(the_minimum))
NULL

#' Numerical Initial Minimization Using a Stepwise Approach
#'
#' @title Obtain the Minimum Value of \code{x} Where \code{f(x)} Reaches a Minimum
#' @name first_min
#'
#' @param f A \code{function}. Must be defined and continuous in the domain \code{[a, b]}. If the function have more than 1 argument, ensure that these are fixed.
#' @param a A \code{double}. The lower bound for the search interval.
#' @param b A \code{double}. The upper bound for the search interval.
#' @param tol A \code{double}. The desired accuracy.
#' @param step_init A \code{double}. The initial step size multiplier. This number of multiplied by the length of \code{[a, b]} to get the initial step size \eqn{\Delta_0}.
#' @param max_iter An \code{integer}. The maximum number of iteration that should be performed before the algorithm forces to quit.
#'
#' @details
#' Given a particular function \code{f}, obtains the first local minimum of \code{f} in the domain \code{[a, b]}.
#' For each iteration, we check whether \eqn{f'(\cdot) > 0}.
#' The i-th search interval is given by \eqn{[a + \Delta_0 \sum_{j=0}^{i-2} 2^{j}, a + \Delta_0 \sum_{j=0}^{i-1} 2^{j}\,]}.
#' If a minimum is not found before \eqn{a + \Delta_0 \sum_{j=0}^{i-1} 2^{j} > b}, \code{brent_min} is called instead.
#' Note that this algorithm works best if \code{f} is a differentiable and smooth function. Note also that If \eqn{f'(a) > 0}, this algorithm will
#' return \code{a}, so this algorithm is most useful if \eqn{f'(x) < 0} in the start of the interval \code{[a, b]}.
#'
#' @return A \code{double} that signify the value of \code{x} that results in the initial minimum of \code{f}.
#' @export
#'
#' @examples
#' example_fun <- function(x, a = 3){return((x - a)^2)}
#' the_first_minimum <- first_min(f = function(x) example_fun(x, 3), a = -3, b = 6)
#'
#' # Expected to be approximately '3'
#' print(the_first_minimum)
#'
#' # The value of f at the minimum
#' print(example_fun(the_first_minimum))
NULL

numerical_gradient <- function(x, f, eps = 1e-4, r = 4L) {
    .Call(`_smooth_commutability_numerical_gradient`, x, f, eps, r)
}

brent_min <- function(f, a, b, tol = 1.22e-4, max_iter = 100L) {
    .Call(`_smooth_commutability_brent_min`, f, a, b, tol, max_iter)
}

first_min <- function(f, a, b, tol = 1e-8, step_init = 1e-4, max_iter = 1000L) {
    .Call(`_smooth_commutability_first_min`, f, a, b, tol, step_init, max_iter)
}

#' Computes the absolute effective degrees of freedom error
#'
#' @title Computes the absolute effective degrees of freedom error
#' @name error_df2
#'
#' @param sp A \code{double}, and is a scale-free variant of the computational lambda. Given this value of \code{lambda}, the trace of the smoother matrix is calculated and the absolute deviation between this and the given \code{df} is recorded.
#' @param df A \code{double} that corresponds to the target effective degrees of freedom for the smoothing spline model.
#' @param weights A \code{numeric} vector sorted according to the order of the predictor \code{x}.
#' @param B A B-spline basis \code{matrix} evaluated at the sorted and unique values of the predictor values, \code{x}.
#' @param BTB A \code{matrix} that is the matrix product between the transpose of \code{B} and \code{B}.
#' @param Omega The O'Sullivan penalty \code{matrix} for the B-spline basis.
#' @param r The trace ratio of the matrices
#'
#' @description
#' Given a value of \code{lambda}, the corresponding effective degrees of freedom is calculated. This value of the degrees of freedom is compared to \code{df}. This comparison is done by taking the absolute difference between the effective degrees of freedom associated with the \code{lambda} given and the provided value of \code{df}. This function is primarily used to convert a value of \code{df} to a suitable value of \code{lambda} using numerical optimization. See \code{to_lambda} for more details.
#'
#'
#' @return A \code{double} that signify the absolute deviation between the trace of the smoother matrix (given the value of \code{lambda}) and the provided value of \code{df}.
#' @export
#'
#' @examples print(1)
NULL

error_df2 <- function(sp, df, weights, B, BTB, Omega, r = 1.0) {
    .Call(`_smooth_commutability_error_df2`, sp, df, weights, B, BTB, Omega, r)
}

#' Checks if \eqn{y_{n+j}} for \eqn{j = 1, \ldots, m} are inside Deming prediction intervals.
#'
#' @title Check Whether New Observations Are Inside Deming Prediction Intervals
#' @name inside_deming2
#'
#' @param data A \code{list} or \code{data.table}. Must contain \code{MP_A} (response variable values)
#'        and \code{MP_B} (predictor variable values).
#' @param new_data A \code{list} or \code{data.table}. Must contain \code{MP_A} (new response variable values)
#'        and \code{MP_B} (new predictor variable values).
#' @param imprecision_estimates A \code{list} or \code{data.table}. Must contain \code{lambda}
#'        and \code{Var_B}. See details for more information.
#' @param R A \code{integer} value. The number of replicated measurements. If the number of
#'        replicated measurements is sample-dependent, use some summary statistic.
#'        Defaults to \code{3}.
#' @param R_ratio A \code{double} value. If a different number of replicated measurements are used
#'        in data than in new_data, specify the ratio here. Defaults to \code{1}.
#' @param level A \code{double} value. The desired nominal confidence level for
#'        the estimated Deming prediction intervals. Must be between \code{0} and \code{1}.
#'        Sensible values include values larger than or equal to \code{0.50}. Defaults to \code{0.99}.
#'
#'
#' @details
#' The Deming regression \eqn{\mathrm{level} \cdot 100\%} prediction intervals are calculated by
#'
#' \eqn{PI_D(y_{n+j} | x_{n+j}) \approx b_0 + b_1 \cdot x_{n+j} \pm t_{n - 2, 1 - \alpha/2} \sqrt{\hat{\sigma}_{b_1}^2\Big[(\hat{x}_{n+j}^L - \hat{\mu})^2 + \tilde{\sigma}_h^2 \cdot R_{\mathrm{rat}}\Big] + R_{\mathrm{rat}} \cdot \Big(\frac{n+j}{n}\Big) \cdot (\tilde{\sigma}_v^2 + b_1^2 \cdot \tilde{\sigma}_h^2)}}
#'
#' This function calculates \eqn{z_j = \mathbb{I}\big[y_{n+j} \in PI_D(y_{n+j} | x_{n+j})\big]}
#' for each \eqn{j = 1, \ldots, m}. Note that
#' \itemize{
#'   \item \eqn{b_1} is the Deming regression slope estimate of \eqn{\beta_1}.
#'   \item \eqn{\hat{\sigma}_{b_1}^2} is the estimated variance of the Deming regression slope estimator \eqn{b_1}.
#'   \item \eqn{\hat{x}_{n+j}^L} is an estimate of the latent \eqn{x_{n+j}^L}.
#'   \item \eqn{\hat{\mu}} is an estimate of the mean of \eqn{x_{i}^L}.
#'   \item \eqn{\tilde{\sigma}_h^2} is the method of moments estimator of the repeatability variance \eqn{\sigma_h^2}.
#'   \item \eqn{\tilde{\sigma}_v^2} is the method of moments estimator of the repeatability variance \eqn{\sigma_v^2}.
#'   \item \eqn{R_{\mathrm{rat}}} is the \code{R_ratio} value.
#' }
#'
#' Missing values in \code{MP_A} or \code{MP_B} in \code{data} are allowed and will be silently removed
#' before \eqn{z_j} values are calculated. Missing values in \code{MP_A} or \code{MP_B} in \code{new_data}
#' are allowed, but corresponding \eqn{z_j} values will not be calculated in such cases.
#'
#' Note that \code{imprecision_estimates} should contain the following variables:
#' \itemize{
#'   \item \code{lambda}: This an estimator of the ratio \eqn{\sigma_v^2 / \sigma_h^2}.
#'         How you estimate this ratio is up to you. However, a natural estimator is
#'         \eqn{\hat{\sigma}_v^2 / \hat{\sigma}_h^2}, where \eqn{\hat{\sigma}_v^2} and
#'         \eqn{\hat{\sigma}_h^2} are pooled variances based on replicated measurements.
#'   \item \code{Var_B}: This is an estimator of \eqn{\sigma_h^2}. How you estimate this
#'         ratio is up to you. However a natural estimator is \eqn{\hat{\sigma}_h^2},
#'         which is a pooled variance based on replicated measurements.
#' }
#' N.B., if either \code{lambda} or \code{Var_B} is missing or takes negative values
#' Ordinary least squares regression is used instead to calculate \eqn{z_j} values.
#'
#'
#' @return An \code{integer} vector of length equal to the number of rows in \code{new_data}.
#'
#' @examples \dontrun{
#'   print(1)
#' }
inside_deming2 <- function(data, new_data, imprecision_estimates, R = 3L, R_ratio = 1.0, level = 0.99) {
    .Call(`_smooth_commutability_inside_deming2`, data, new_data, imprecision_estimates, R, R_ratio, level)
}

#' Calculates the Deming regression estimate of \eqn{\sigma_h^2}.
#'
#' @title Calculates the Deming Regression Estimate of \eqn{\sigma_h^2}.
#' @name sigma_h_squared_deming2
#'
#' @param data A \code{list} or \code{data.table}. Must contain \code{MP_A} (response variable values)
#'        and \code{MP_B} (predictor variable values).
#' @param lambda A \code{double} value.
#'
#' @details
#' This function is typically not relevant for end-users.
#'
#'
#' @return An \code{double} that is the Deming regression estimate of \eqn{\sigma_h^2}.
#'
#' @examples \dontrun{
#'   print(1)
#' }
sigma_h_squared_deming2 <- function(data, lambda = 1) {
    .Call(`_smooth_commutability_sigma_h_squared_deming2`, data, lambda)
}

#' @title Estimate Weighted Local-Average Curve
#' @name local_average
#'
#' @param x A \code{numeric} vector. Must contain the stochastic process
#'          values that are used in estimating the weighted local average
#'          curve.
#' @param weights A \code{numeric} vector. Must contain weights for each of
#'                the stochastic process values. If all equal to \code{1},
#'                weighting is bypassed.
#' @param window An \code{integer}. The width of the moving window.
#'               See details.
#'
#' @description
#' Estimates the weighted local-average for a stochastic process \code{x}.
#'
#' @details
#' Calculates the estimated weighted local-averages for the stochastic
#' process values \eqn{\lbrace x_i \rbrace_{i=1}^{N}}. The estimation
#' utilizes weights \eqn{\lbrace w_i \rbrace_{i=1}^{N}}. We assume the
#' following model:
#'
#' \eqn{x_i = f(x_i) + \epsilon_i}.
#'
#' The goal is to extract the signal \eqn{f(x_i)}, using a weighted
#' local-average model:
#'
#' \eqn{\hat{f}(x_i) = \frac{1}
#' {w_i \cdot (\min\lbrace N, i + \Delta \rbrace - \max\lbrace 1, i - \Delta
#' \rbrace)} \cdot \sum_{j = \max\lbrace 1, i - \Delta \rbrace}^{\min\lbrace
#' N, i + \Delta \rbrace} x_j}
#'
#' Here, \eqn{\Delta} is \eqn{0.5 \times} \code{window}. Note: \code{NA}
#' values are allowed in \code{x}, and will be silently removed if present.
#'
#' @return
#' A \code{numeric} vector. The weighted local-average estimates of \code{x}.
#'
#' @examples \dontrun{
#'   print(1)
#' }
local_average <- function(x, weights, window) {
    .Call(`_smooth_commutability_local_average`, x, weights, window)
}

#' N-fold cross-validation estimate of the mean squared prediction error of the smoothing spline model
#'
#' @title N-fold cross-validation estimate of the mean squared prediction error of the smoothing spline model
#' @name nfold_cv2
#'
#' @param sp A non-negative \code{double}. This is a scaled version of the raw smoothing parameter lambda and is usually what is optimized.
#' @param y A \code{numeric} vector sorted according to the order of the predictor \code{x}.
#' @param weights A \code{numeric} vector sorted according to the order of the predictor \code{x}.
#' @param B A B-spline basis \code{matrix} evaluated at the sorted and unique values of \code{x} .
#' @param BTB A \code{matrix} that is the matrix product between the transpose of \code{B} and \code{B}.
#' @param Omega The penalty \code{matrix} for the B-spline basis.
#' @param cross_validation A \code{logical} value. If set to \code{TRUE}, you are effectively prompting that the lambda inputs are equivalent to the spar smoothing parameter.
#' @param r The trace ratio of the matrices
#'
#' @return A \code{double} that signify the n-fold cross-validation score
#' @export
#'
#' @examples print(1)
NULL

#' Generalized cross-validation estimate of the mean squared prediction error of the smoothing spline model
#'
#' @title Generalized cross-validation estimate of the expected mean squared prediction error of the smoothing spline model
#' @name gcv2
#'
#' @param sp A non-negative \code{double}. This is a scaled version of the raw smoothing parameter lambda and is usually what is optimized.
#' @param y A \code{numeric} vector sorted according to the order of the predictor \code{x}.
#' @param weights A \code{numeric} vector sorted according to the order of the predictor \code{x}.
#' @param B A B-spline basis \code{matrix} evaluated at the sorted and unique values of \code{x} .
#' @param BTB A \code{matrix} that is the matrix product between the transpose of \code{B} and \code{B}.
#' @param Omega The penalty \code{matrix} for the B-spline basis.
#' @param cross_validation A \code{logical} value. If set to \code{TRUE}, you are effectively prompting that the lambda inputs are equivalent to the spar smoothing parameter.
#' @param r The trace ratio of the matrices
#' @param smudge A \code{double} larger than or equal to 1. Set to \code{1.2} or
#'        \code{1.4} to avoid undersmoothing.
#'
#' @return A \code{double} that signify the GCV cross-validation score.
#' @export
#'
#' @examples print(1)
NULL

nfold_cv2 <- function(sp, y, weights, B, BTB, Omega, cross_validation = FALSE, r = 1.0) {
    .Call(`_smooth_commutability_nfold_cv2`, sp, y, weights, B, BTB, Omega, cross_validation, r)
}

gcv2 <- function(sp, y, weights, B, BTB, Omega, cross_validation = FALSE, r = 1.0, smudge = 1.4) {
    .Call(`_smooth_commutability_gcv2`, sp, y, weights, B, BTB, Omega, cross_validation, r, smudge)
}

#'
#' @title Obtain optimal upper limit for constrained search grid for optimal df
#' @name obtain_df_max
#'
#' @param df A \code{numeric} vector signifying the grid in which second derivatives of zeta are evaluated
#' @param m A \code{numeric} vector signifying the evaluated second derivatives of zeta
#' @param threshold A \code{double}. Which relative value of the maximum found second derivative should be used as tolerance. Must be between 0 and 1.
#'
#' @description Computes the first value of \code{df} where the curve of zeta starts to increase after initial decrease.
#'
#' @details Used to constrain the search grid for an optimal value of \code{df}.
#'
#' @return A \code{double}. The upper limit for the constrained search grid for optimal \code{df}.
#'
#' @examples \dontrun{
#'   print(1)
#' }
NULL

obtain_df_max <- function(df, second_deriv, threshold = 0.05) {
    .Call(`_smooth_commutability_obtain_df_max`, df, second_deriv, threshold)
}

#' Reconstruct a 4-banded matrix based on flattened data
#'
#' @title Reconstruct a 4-banded matrix based on flattened data
#' @name reconstruct_4_band_matrix
#'
#' @param x A \code{numeric} vector signifying the flattened version of the 4-banded matrix.
#'
#' @description Reconstructs a 4-banded matrix based on flattened data.
#'
#' @details This reconstruction assumes symmetrical 4-banded matrix. End-users should not bother with this function.
#'
#' @return A 4-banded \code{matrix}.
#'
#' @examples \dontrun{
#'   print(1)
#' }
reconstruct_4_band_matrix <- function(x) {
    .Call(`_smooth_commutability_reconstruct_4_band_matrix`, x)
}

#' Reconstruct matrices based on smooth.spline output
#'
#' @title Reconstruct matrices based on smooth.spline output
#' @name get_matrices
#'
#' @param auxM A \code{List} containing the \code{auxM} object from the smooth.spline fit.
#'
#' @description Reconstructs the penalty and B-spline matrices based on flattened data.
#'
#' @details This reconstruction assumes symmetrical 4-banded matrices. End-users should not bother with this function.
#'
#' @return A list of two 4-banded \code{matrix} objects and one \code{numeric} vector.
#'
#' @examples \dontrun{
#'   print(1)
#' }
get_matrices <- function(auxM) {
    .Call(`_smooth_commutability_get_matrices`, auxM)
}

