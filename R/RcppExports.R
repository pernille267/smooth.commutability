# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Calculate a Statistic for Each Sample
#'
#' @title Calculate a Statistic for Each Sample
#' @name fun_of_replicates2
#'
#' @param data A \code{data.table} or \code{list} object. Must contain
#'        \code{SampleID}, \code{ReplicateID}, \code{MP_A} and \code{MP_B}.
#' @param fun A \code{character} string. Which statistic is to be calculated for
#'        each SampleID. Possible choices include \code{mean}, \code{var} (variance),
#'        \code{sd} (standard deviaton), \code{cv} (coefficient of variation),
#'        \code{median}, \code{min} (minimum) and \code{max} (maximum).
#'
#' @description Calculates a chosen statistic over the replicates.
#'
#' @details This function handles NA-values automatically.
#'
#' @return A \code{list} with elements \code{SampleID}, \code{MP_A} and \code{MP_B}.
#'         \code{MP_A} and \code{MP_B} contains the sample-wise statistics.
#'
#' @examples \dontrun{
#'   print(1)
#' }
fun_of_replicates2 <- function(data, fun = "mean") {
    .Call(`_smooth_commutability_fun_of_replicates2`, data, fun)
}

#'
#' @title Obtain optimal upper limit for constrained search grid for optimal df
#' @name obtain_df_max
#'
#' @param df A \code{numeric} vector signifying the grid in which second derivatives of zeta are evaluated
#' @param m A \code{numeric} vector signifying the evaluated second derivatives of zeta
#' @param threshold A \code{double}. Which relative value of the maximum found second derivative should be used as tolerance. Must be between 0 and 1.
#'
#' @description Computes the first value of \code{df} where the curve of zeta starts to increase after initial decrease.
#'
#' @details Used to constrain the search grid for an optimal value of \code{df}.
#'
#' @return A \code{double}. The upper limit for the constrained search grid for optimal \code{df}.
#'
#' @examples \dontrun{
#'   print(1)
#' }
NULL

obtain_df_max <- function(df, second_deriv, threshold = 0.05) {
    .Call(`_smooth_commutability_obtain_df_max`, df, second_deriv, threshold)
}

#' Reconstruct a 4-banded matrix based on flattened data
#'
#' @title Reconstruct a 4-banded matrix based on flattened data
#' @name reconstruct_4_band_matrix
#'
#' @param x A \code{numeric} vector signifying the flattened version of the 4-banded matrix.
#'
#' @description Reconstructs a 4-banded matrix based on flattened data.
#'
#' @details This reconstruction assumes symmetrical 4-banded matrix. End-users should not bother with this function.
#'
#' @return A 4-banded \code{matrix}.
#'
#' @examples \dontrun{
#'   print(1)
#' }
reconstruct_4_band_matrix <- function(x) {
    .Call(`_smooth_commutability_reconstruct_4_band_matrix`, x)
}

#' Reconstruct matrices based on smooth.spline output
#'
#' @title Reconstruct matrices based on smooth.spline output
#' @name get_matrices
#'
#' @param auxM A \code{List} containing the \code{auxM} object from the smooth.spline fit.
#'
#' @description Reconstructs the penalty and B-spline matrices based on flattened data.
#'
#' @details This reconstruction assumes symmetrical 4-banded matrices. End-users should not bother with this function.
#'
#' @return A list of two 4-banded \code{matrix} objects and one \code{numeric} vector.
#'
#' @examples \dontrun{
#'   print(1)
#' }
get_matrices <- function(auxM) {
    .Call(`_smooth_commutability_get_matrices`, auxM)
}

#' Calculate imprecision point estimates of measurements in a given IVD-MD comparison
#'
#' @title Calculate imprecision point estimates of measurements in a given IVD-MD comparison
#' @name global_precision_estimates2
#'
#' @param data \code{list} or \code{data.table}. Must contain the following variables:
#' \itemize{
#'   \item \code{SampleID}: Sample identifiers. Must be \code{character}.
#'   \item \code{ReplicateID}: Replicate measurement identifiers within samples. Must be \code{character}.
#'   \item \code{MP_A}: Measurement results for the IVD-MD used as response variable.
#'   \item \code{MP_B}: Measurement results for the IVD-MD used as predictor variable.
#' }
#'
#' @details
#' Calculates five relevant global imprecision estimates. The term global is
#' used because these imprecision estimates are based on the whole dataset.
#' These five imprecision estimates are calculated:
#' \itemize{
#'   \item{\code{Var_A: }}{Pooled variance of all sample-variances based on MP_A}
#'   \item{\code{Var_B: }}{Pooled variance of all sample-variances based on MP_B}
#'   \item{\code{CV_A: }}{CV estimate based on Var_A and the grand mean of all measurements from MP_A}
#'   \item{\code{CV_B: }}{CV estimate based on Var_B and the grand mean of all measurements from MP_B}
#'   \item{\code{lambda: }}{Ratio of pooled variances Var_A and Var_B}
#' }
#' CV values \code{CV_A} and \code{CV_B} can also be represented in percent.
#' To convert these to percentage values, one just multiply their raw results by 100%.
#'
#'
#' @return A \code{list} of length \code{5} with the following point imprecision estimates:
#'         \code{Var_A}, \code{Var_B}, \code{CV_A}, \code{CV_B} and \code{lambda}.
#'         See details for more information on these statistics.
#'
#' @examples \dontrun{
#'   library(data.table)
#'   data <- simulate_eqa_data2(list(n = 25, R = 3, cvx = 0.02, cvy = 0.3), AR = TRUE)
#'   data$SampleID <- as.character(data$SampleID)
#'   data$ReplicateID <- as.character(data$ReplicateID)
#'   print(global_prcision_estimates2(data = data) |> as.data.table())
#' }
NULL

#' Resample clustered EQA clinical sample data
#'
#' @title Resample clustered EQA clinical sample data
#' @name resample_samples2
#'
#' @param data A \code{list} or a \code{data.table}. Must contain \code{SampleID},
#'        \code{ReplicateID}, \code{MP_A} and \code{MP_B}. The ID variables \code{SampleID}
#'        and \code{ReplicateID} must be of character type for the function to operate correctly.
#'
#' @details
#' This function is a very efficient method to resample clinical sample data on sample-level.
#' It is convenient to combine this function with \code{fasteqa} functions such as
#' \itemize{
#'   \item \code{global_precision_estimates()} to estimate bootstrap imprecision confidence intervals
#'   \item \code{estimate_zeta()} to estimate bootstrap zeta confidence intervals
#' }
#' Alternatively it could be used to estimate \code{smooth.commutability} functions such as
#' \itemize{
#'   \item \code{estimate_zeta_ss()} to estimate bootstrap smoothing spline zeta confidence intervals
#'   \item \code{estimate_df()} to estimate bootstrap smoothing spline df confidence intervals
#' }
#'
#' @return A \code{list} containing the resampled EQA clinical sample data.
#'
#' @examples
#' library(data.table)
#' fictive_data <- simulate_eqa_data2(list(n = 25, R = 3, cvx = 0.01, cvy = 0.01), AR = TRUE)
#' resampled_data <- resample_samples2(fictive_data)
#' setDT(resampled_data)
#' print(resampled_data)
NULL

#' Resample cluster statistics based on EQA clinical sample data
#'
#' @title Resample cluster statistics based on EQA clinical sample data
#' @name resample_fun_samples2
#'
#' @param data A \code{list} or a \code{data.table}. The mean-of-replicates
#'        clinical sample data. Must contain \code{SampleID}, \code{MP_A} and \code{MP_B}.
#'        The ID variable \code{SampleID} must be \code{character}.
#' @param weight_data A \code{list} or a \code{data.table}. The weight data based
#'        on the clinical sample data. Must contain \code{SampleID}, \code{MP_A} and \code{MP_B}.
#'        The ID variable \code{SampleID} must be \code{character}.
#'
#' @details
#' This function is a very efficient method to resample aggregated sample statistics
#' based on clinical sample data.
#'
#' It is convenient to combine this function with \code{smooth.commutability} functions such as
#' \itemize{
#'   \item \code{predict_smoothing_splines()} to estimate inside rates for a IVD-MD comparison
#'   \item \code{smoothing_spline()} to estimate bootstrap distribution of LOO-CV chosen effective degrees of freedom.
#' }
#' If you do not have weight data available that you seek to resample jointly,
#' just pass \code{data} as both first and second argument.
#' See example under documentation of \code{resample_fun_samples2_all}.
#'
#' @return
#' A \code{list} of length two containing the resampled cluster statistics based on
#' \code{data} and \code{weight_data}. The output \code{list} have the following structure:
#' \itemize{
#'   \item \code{resampled_cs_data}: Contains the resampled \code{data}
#'   \item \code{resampled_weight_data}: Contains the resampled \code{weight_data}
#' }
#'
#'
#' @examples
#' library(data.table)
#' fictive_data <- simulate_eqa_data2(list(n = 25, R = 3, cvx = 0.01, cvy = 0.02))
#' fictive_weight_data <- simulate_eqa_data2(list(n = 25, R = 3, cvx = 0.03, cvy = 0.02))
#' resampled_data <- resample_fun_samples2(fictive_data, fictive_weight_data)
#' setDT(resampled_data)
#' print(resampled_data)
NULL

#' Resample cluster statistics based on EQA clinical sample data for each IVD-MD comparison
#'
#' @title Resample cluster statistics based on EQA clinical sample data for each IVD-MD comparison
#' @name resample_fun_samples2_all
#'
#' @param data A \code{list} or a \code{data.table}. The mean-of-replicates
#'        clinical sample data. Must contain \code{comparison} \code{SampleID},
#'        \code{MP_A} and \code{MP_B}. The ID variables \code{comparison}
#'        and \code{SampleID} must be \code{character}.
#' @param weight_data A \code{list} or a \code{data.table}. The weight data based
#'        on the clinical sample data. Must contain \code{comparison} \code{SampleID},
#'        \code{MP_A} and \code{MP_B}.The ID variables \code{comparison}
#'        and \code{SampleID} must be \code{character}.
#'
#' @details
#' This function is a very efficient method to resample aggregated sample statistics
#' based on clinical sample data grouped by IVD-MD \code{comparison}.
#'
#' It is convenient to combine this function with \code{smooth.commutability} functions such as
#' \itemize{
#'   \item \code{predict_smoothing_splines()} to estimate inside rates for each IVD-MD comparison
#'   \item \code{smoothing_spline()} to estimate bootstrap distribution of LOO-CV chosen effective degrees of freedom.
#' }
#' If you do not have weight data available that you seek to resample jointly,
#' just pass \code{data} as both first and second argument. See example.
#'
#' @return
#' A \code{list} of length two containing the resampled cluster statistics based on
#' \code{data} and \code{weight_data}. The output \code{list} have the following structure:
#' \itemize{
#'   \item \code{resampled_cs_data}: Contains the resampled \code{data}
#'   \item \code{resampled_weight_data}: Contains the resampled \code{weight_data}
#' }
#'
#'
#' @examples
#' library(data.table)
#' fictive_data1 <- simulate_eqa_data2(list(n = 25, R = 3, cvx = 0.01, cvy = 0.02))
#' fictive_data2 <- simulate_eqa_data2(list(n = 25, R = 3, cvx = 0.03, cvy = 0.02))
#' fictive_data1$comparison <- rep("A - B", length(fictive_data1$MP_B))
#' fictive_data2$comparison <- rep("A - C", length(fictive_data2$MP_B))
#' fictive_data <- rbindlist(list(fictive_data1, fictive_data2))
#' resampled_data <- resample_fun_samples2_all(fictive_data, fictive_data)
#' setDT(resampled_data)
#' print(resampled_data)
NULL

#' Resample imprecision estimates based on clustered EQA clinical sample data
#'
#' @title Resample imprecision estimates based on clustered EQA clinical sample data
#' @name resample_imprecision2
#'
#' @param data A \code{list} or a \code{data.table}. Must contain \code{SampleID},
#'        \code{ReplicateID}, \code{MP_A} and \code{MP_B}. The ID variables \code{SampleID}
#'        and \code{ReplicateID} must be of character type for the function to operate correctly.
#'
#' @details
#' This function is a very efficient method to resample repeatability in clinical sample data.
#'
#' @return A \code{list} containing the resampled imprecision.
#'
#' @examples
#' library(data.table)
#' fictive_data <- simulate_eqa_data2(list(n = 25, R = 3, cvx = 0.01, cvy = 0.01), AR = TRUE)
#' impr <- replicate(n = 5, expr = resample_imprecision2(fictive_data), simplify = FALSE)
#' print(impr)
NULL

global_precision_estimates2 <- function(data) {
    .Call(`_smooth_commutability_global_precision_estimates2`, data)
}

resample_samples2 <- function(data) {
    .Call(`_smooth_commutability_resample_samples2`, data)
}

resample_fun_samples2 <- function(data, weight_data) {
    .Call(`_smooth_commutability_resample_fun_samples2`, data, weight_data)
}

resample_fun_samples2_all <- function(data, weight_data) {
    .Call(`_smooth_commutability_resample_fun_samples2_all`, data, weight_data)
}

resample_imprecision2 <- function(data) {
    .Call(`_smooth_commutability_resample_imprecision2`, data)
}

#' Simulation of EQA data based on study design and potential differences in non-selectivity
#'
#' @title Simulation of EQA data based on study design and potential differences in non-selectivity
#' @name simulate_eqa_data2
#'
#' @param parameters A \code{list} of parametedrs used to simulate the EQA data. You must at least specify one parameter for this function to run. Except that one mandatory parameter, you may optionally choose the remaining of the parameters. These are the optimal parameters that you may include into the list:
#' \itemize{
#'   \item{\code{n: }}{  The number of clinical samples}
#'   \item{\code{R: }}{The number of replicates on each sample}
#'   \item{\code{cvx: }}{The analytical CV of x measurements}
#'   \item{\code{cvy: }}{The analytical CV of y measurements}
#'   \item{\code{cil: }}{The lower range of the concentration interval}
#'   \item{\code{ciu: }}{The upper range of the concentration interval}
#'   \item{\code{dist: }}{The distribution to simulate latent variables from. Possbile choices include 'unif' (uniform distribution, default), 'norm' (normal distribution) , 'lst' (location-scale t-distribution), 'lnorm' (log-normal distribution)}
#'   \item{\code{df_tau: }}{The degrees of freedom for the 'lst' distribution if the distribution of latent variables are location-scale t-distributed ('lst'). Defaults to 5 if not otherwise is specified.}
#'   \item{\code{eta: }}{The heteroscedasticity factor}
#'   \item{\code{eta0: }}{The proportion of base MS standard deviations}
#'   \item{\code{qpos: }}{Position of systematic differences in non-selectivity. 0 signify lower range and 1 signify upper range}
#'   \item{\code{qran: }}{Interquantile range where systematic differences in non-selectivity should have its effect}
#'   \item{\code{prop: }}{average proportion of clinical samples affected by random differences in non-selectivity}
#'   \item{\code{mmax: }}{The maximum relocation magnitude in number of analytical SDs of y measurements. This assumes either prop or qpos and qran to be specified as well}
#'   \item{\code{b0: }}{For systematic linear DINS between IVD-MDs. Intercept. Defaults to 0.}
#'   \item{\code{b1: }}{For systematic linear DINS between IVD-MDs. Slope. Defaults to 1.}
#'   \item{\code{c0: }}{For systematic linear non-selectivity in IVD-MD 1. Intercept. Defaults to 0.}
#'   \item{\code{c1: }}{For systematic linear non-selectivity in IVD-MD 1. Slope. Defaults to 1.}
#'   \item{\code{error_dist: }}{The distribution to simulate measurement error components from. Possible choices include 'norm' (normal distribution, default) and 'lt' (location t-distribution)}
#'   \item{\code{dfx: }}{The degrees of freedom for the measurement error components in IVD-MD 1 if error_dist = 'lt'. Defaults to 5 if not otherwise is specified.}
#'   \item{\code{dfy: }}{The degrees of freedom for the measurement error components in IVD-MD 2 if error_dist = 'lt'. Defaults to 5 if not otherwise is specified.}
#'   \item{\code{md_method: }}{Method for simulation missing data. Possible choices include 'none' (no missing data is simulated, default), 'mar' (missing at random), 'mnar' (missing not at random) and 'marmnar' (missing both at random and not at random)}
#'   \item{\code{mar_prob: }}{The probability (value between 0 and 1) of having a missing measurement. Only relevant if \code{md_method} is 'mar' or 'marmnar'. If not specified, but \code{md_method} = 'mar' or \code{md_method} = 'marmnar', it defaults to 0.05.}
#'   \item{\code{mnar_threshold: }}{The lower bound threshold (a real value) for when a measurement should be missing. Only relevant if \code{md_method} is 'mnar' or 'marmnar'. If not specified, but \code{md_method} = 'mnar' or \code{md_method} = 'marmnar', it defaults to \code{cil}. Alternatively, if not specified, but \code{md_method} = 'mnar0' or \code{md_method} = 'marmnar0', it defaults to 0.}
#'
#' }
#' @param type \code{integer}. Set to \code{0} for default simulation of data. Set to \code{1}, \code{2} or \code{3} to simulate from custom built in non-linear functions.
#' @param AR \code{logical}. If \code{TRUE}, data is simulated including replicated measurements. Otherwise, mean of replicated measurements are returned (MOR).
#' @param include_parameters \code{logical}. If \code{TRUE}, the used parameters in the data simulation is saved and placed in a seperate list as part of the output.
#' @param shift \code{logical}. If \code{TRUE}, the simulated data change roles. MP_A becomes MP_B, and MP_B becomes MP_A.
#'
#' @description Simulates a data set with n x R rows, and four columns. The two first columns are the base ID columns (\code{SampleID} and \code{ReplicateID}). The remaining columns are numeric columns holding measurement results from the two IVD-MDs in comparison (denoted 'MP_A' (y) and 'MP_B' (x)).
#'              The form of the simulated data depends greatly on which parameters are specified in the the \code{parameters} argument.
#' @details Simulates method comparison data for \code{n} samples (e.g., clinical samples, pools, external quality assessment samples, reference material samples), where each sample is measured \code{R} times (replicated measurements). In theory, we simulate from (x_ir, y_ir) where x_ir = f(tau_i) + h_ir and y_ir = g(f(tau_i)) + v_ir.
#'          The form of f is specified through parameters \code{c0} and \code{c1}, whereas g is specified through numerous parameters such as \code{b0}, \code{b1}, \code{qpos}, \code{qran}, \code{mmax}, \code{prop}. tau_i is modelled through \code{cil}, \code{ciu}, \code{dist} and \code{df_tau}.
#'          h_ir and v_ir are measurement error components modelled through \code{cvx}, \code{cvy}. \code{cvx}, \code{cvy} can be functions of \code{error_dist}, \code{dfx}, \code{dfy}, \code{eta} and \code{eta0}.
#'          In order to convert the outputted list to a table, use either \code{as.data.frame()}, \code{as.data.table()}, \code{as.tibble()}. The most efficient way to convert is \code{setDT()} from the \code{data.table} package.
#'
#' @return A list where each list element is a column of the generated EQA data
#'
#' @examples \dontrun{
#'
#'   # Load data.table package from library
#'   library(data.table)
#'
#'   # Simulate 25 clinical samples measured in triplicate affected by
#'   # random differences in non-selectivity
#'   parameters_css <- list(n = 25, R = 3, prop = 0.1, mmax = 5, cil = 25, ciu = 75)
#'   simulated_css <- simulate_eqa_data(parameters = parameters_css)
#'
#'   # Simulate 3 external quality assessment material samples
#'   # measured in duplicate not affected by differences in non-selectivity
#'   parameters_eqams <- list(n = 3, R = 2, b0 = 0.1, b1 = 1.1)
#'   simulated_eqams <- simulate_eqa_data(parameters = parameters_eqams)
#'
#'   # We can assume that tau_i ~ lst(df_tau = 10, mu_tau = 50, var_tau = 78.583)
#'   parameters_css <- c(parameters_css, dist = "lst", df_tau = 10)
#'   simulated_css_lst <- simulate_eqa_data(parameters = parameters_css)
#'
#'   # We can convert the list objects to data.table objects using setDT()
#'   setDT(simulated_css)
#'   setDT(simulated_eqams)
#'   setDT(simulated_css_lst)
#'
#'   # Print results
#'   print(simulated_css)
#'   print(simulated_eqams)
#'   print(simulated_css_lst)
#'
#' }
#'
NULL

simulate_eqa_data2 <- function(parameters, type = 1L, AR = FALSE, include_parameters = FALSE, shift = FALSE) {
    .Call(`_smooth_commutability_simulate_eqa_data2`, parameters, type, AR, include_parameters, shift)
}

