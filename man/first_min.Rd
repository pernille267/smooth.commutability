% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{first_min}
\alias{first_min}
\title{Obtain the Minimum Value of \code{x} Where \code{f(x)} Reaches a Minimum}
\arguments{
\item{f}{A \code{function}. Must be defined and continuous in the domain \code{[a, b]}. If the function have more than 1 argument, ensure that these are fixed.}

\item{a}{A \code{double}. The lower bound for the search interval.}

\item{b}{A \code{double}. The upper bound for the search interval.}

\item{tol}{A \code{double}. The desired accuracy.}

\item{step_init}{A \code{double}. The initial step size multiplier. This number of multiplied by the length of \code{[a, b]} to get the initial step size \eqn{\Delta_0}.}

\item{max_iter}{An \code{integer}. The maximum number of iteration that should be performed before the algorithm forces to quit.}
}
\value{
A \code{double} that signify the value of \code{x} that results in the initial minimum of \code{f}.
}
\description{
Numerical Initial Minimization Using a Stepwise Approach
}
\details{
Given a particular function \code{f}, obtains the first local minimum of \code{f} in the domain \code{[a, b]}.
For each iteration, we check whether \eqn{f'(\cdot) > 0}.
The i-th search interval is given by \eqn{[a + \Delta_0 \sum_{j=0}^{i-2} 2^{j}, a + \Delta_0 \sum_{j=0}^{i-1} 2^{j}\,]}.
If a minimum is not found before \eqn{a + \Delta_0 \sum_{j=0}^{i-1} 2^{j} > b}, \code{brent_min} is called instead.
Note that this algorithm works best if \code{f} is a differentiable and smooth function. Note also that If \eqn{f'(a) > 0}, this algorithm will
return \code{a}, so this algorithm is most useful if \eqn{f'(x) < 0} in the start of the interval \code{[a, b]}.
}
\examples{
example_fun <- function(x, a = 3){return((x - a)^2)}
the_first_minimum <- first_min(f = function(x) example_fun(x, 3), a = -3, b = 6)

# Expected to be approximately '3'
print(the_first_minimum)

# The value of f at the minimum
print(example_fun(the_first_minimum))
}
